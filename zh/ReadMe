有好的想法、意见，请Email：zhaoyun004@qq.com


Zh是一套程序设计系统，其基本数据类型和数据结构和Python完全一样。核心是一个解释器，用于解释运行用户编写的各种程序。为了编写程序，用户只需要一个能很漂亮显示程序的文本编辑软件，推荐使用开源、免费软件：Notepad++、Sublime Text。

用户获得软件是非常容易的，但是获得正确的编程知识确很难。众多的程序设计系统，可能让人眼花缭乱，抓不住重点。本人才疏学浅，可能会误导同学，请认真思考、鉴定。


一、系统需求：Python3


二、下载源代码、运行测试

git clone https://github.com/zhangyun007/Zh.git

运行python Zh.py进入单行交互模式。

运行python Zh.py test.s解释执行test.s文件，测试文件包括：scheme.s test.s new.s first.s newton.s



三、下载Windows可执行文件

我们使用pyinstaller模块生成来了Windows下的exe文件，用户可以直接运行zh.exe进入单行交互模式，或者使用zh.exe test.s解释执行某个文件。


四、文本编辑环境

Windows系统下，推荐使用Notepad++，在菜单栏语言选项里选择Lisp，会将部分关键词彩色显示。注意，不能选择Scheme，选择Scheme，只有黑白显示文本。

其次是Sublime Text3。ST虽然很好，但是对于中文支持总是需要你做一些额外的任务，这种任务是枯燥的，为什么不配置好，下载就能支持UTF-8呢。多次折腾之后，我厌倦了自己去下载插件支持UTF-8。于是，我回头用上了Notepad++。


单行交互模式

运行python Zh.py，进入单行交互模式。

打印hello world:
(print "hello , world!")
print是Python内置函数，可以直接使用。

计算3+4:
(+ 3 4)或者3+4


关键词

下面是系统支持的关键词列表和简单的解释：

set  定义并赋值一个变量
define 定义一个函数
lambda 定义一个无名函数
begin 顺序运算begin之后的语句，返回最后一项。
if 条件分支，返回其中一项。
while for 循环
break 跳出循环
for_each 遍历一个列表
class 自定义类型
env 查看当前环境

True False Nil


内置变量

内置变量可以通过(env g)指令查看:

E:\Project\Zh>python Zh.py
Zh> (env g)
['env']
env ...
+  :  <built-in function add>
-  :  <built-in function sub>
*  :  <built-in function mul>
/  :  <built-in function truediv>
>  :  <built-in function gt>
<  :  <built-in function lt>
>=  :  <built-in function ge>
<=  :  <built-in function le>
=  :  <built-in function eq>
not  :  <function <lambda> at 0x0000000002C2ABF8>
eq?  :  <built-in function is_>
equal?  :  <built-in function eq>
max  :  <built-in function max>
min  :  <built-in function min>
abs  :  <built-in function abs>
round  :  <built-in function round>
tuple  :  <function <lambda> at 0x0000000002C2A510>
dict  :  <function <lambda> at 0x0000000002C2A598>
car  :  <function <lambda> at 0x0000000002C2A620>
cdr  :  <function <lambda> at 0x0000000002C2A6A8>
list  :  <function <lambda> at 0x0000000002C2A730>
|  :  <function <lambda> at 0x0000000002C2A7B8>
append  :  <built-in function add>
len  :  <built-in function len>
map  :  <class 'map'>
print  :  <built-in function print>
exit  :  Use exit() or Ctrl-Z plus Return to exit
open  :  <built-in function open>
procedure?  :  <built-in function callable>
null?  :  <function <lambda> at 0x0000000002C2A840>
bool?  :  <function <lambda> at 0x0000000002C2A8C8>
number?  :  <function <lambda> at 0x0000000002C2A950>
string?  :  <function <lambda> at 0x0000000002C2A9D8>
tuple?  :  <function <lambda> at 0x0000000002C2AA60>
list?  :  <function <lambda> at 0x0000000002C2AAE8>
dict?  :  <function <lambda> at 0x0000000002C2AB70>
and  :  <function <lambda> at 0x0000000002C2AC80>
or  :  <function <lambda> at 0x0000000002C2AD08>
isa  :  <built-in function isinstance>
dir  :  <built-in function dir>
type  :  <class 'type'>
getattr  :  <built-in function getattr>
setattr  :  <built-in function setattr>
.  :  <function <lambda> at 0x0000000002C2AD90>
int  :  {}
__name__  :  math
__doc__  :  This module is always available.  It provides access to the
mathematical functions defined by the C standard.
__package__  :
__loader__  :  <class '_frozen_importlib.BuiltinImporter'>
__spec__  :  ModuleSpec(name='math', loader=<class '_frozen_importlib.BuiltinImp
orter'>, origin='built-in')
acos  :  <built-in function acos>
acosh  :  <built-in function acosh>
asin  :  <built-in function asin>
asinh  :  <built-in function asinh>
atan  :  <built-in function atan>
atan2  :  <built-in function atan2>
atanh  :  <built-in function atanh>
ceil  :  <built-in function ceil>
copysign  :  <built-in function copysign>
cos  :  <built-in function cos>
cosh  :  <built-in function cosh>
degrees  :  <built-in function degrees>
erf  :  <built-in function erf>
erfc  :  <built-in function erfc>
exp  :  <built-in function exp>
expm1  :  <built-in function expm1>
fabs  :  <built-in function fabs>
factorial  :  <built-in function factorial>
floor  :  <built-in function floor>
fmod  :  <built-in function fmod>
frexp  :  <built-in function frexp>
fsum  :  <built-in function fsum>
gamma  :  <built-in function gamma>
gcd  :  <built-in function gcd>
hypot  :  <built-in function hypot>
isclose  :  <built-in function isclose>
isfinite  :  <built-in function isfinite>
isinf  :  <built-in function isinf>
isnan  :  <built-in function isnan>
ldexp  :  <built-in function ldexp>
lgamma  :  <built-in function lgamma>
log  :  <built-in function log>
log1p  :  <built-in function log1p>
log10  :  <built-in function log10>
log2  :  <built-in function log2>
modf  :  <built-in function modf>
pow  :  <built-in function pow>
radians  :  <built-in function radians>
sin  :  <built-in function sin>
sinh  :  <built-in function sinh>
sqrt  :  <built-in function sqrt>
tan  :  <built-in function tan>
tanh  :  <built-in function tanh>
trunc  :  <built-in function trunc>
pi  :  3.141592653589793
e  :  2.718281828459045
tau  :  6.283185307179586
inf  :  inf
nan  :  nan
....
Zh>(exit)

用户可在程序的任何位置调用(env)查看当前块的环境，该关键字用于调试程序，有时候可能比手工打印更方便，毕竟(env)一次打印当前块的所有变量值。

注意：打印出的变量值是一个Python列表：["abc" 1]，第一项是变量值，第二项表示变量是否使用，1意为已经使用过，0表示未使用。


关键词和程序库

关键词是编程系统的核心，而程序库则可视为核心以外的扩展。系统的关键词通常很少，但是库则有千万种，任何人都能为某个程序设计系统扩展一个库。


数据类型：

一、基本数据类型(和Python保持一致)：
int float bool string 

二、复合数据类型(和Python保持一致)：

定义一个元组: 
(set a (tuple 12 34))

定义一个列表: 
(set a (list 12 34))，简写: (set a (' 12 34))

列表元素访问
(set (i (list 12 "hello" 34 True)))
简写：(set (i (' 12 "hello" 34 True)))

(| i 2)      -- 获得i的第二项 34
i|2         -- 意义同上。

列表元素访问操作符为|，不同于大多程序设计系统使用[]访问数组或者列表，我们使用操作符|访问列表元素。用户少敲一个字符，同时解释器的实现也少写一些代码。 


定义一个字典: 
(set (d (dict (' (' "+" +) 
    (' "-" -)
    (' "*" *)
    (' "/" /)
    )))
)

字典元素访问：


中缀表达式：

支持符号中缀表达式：j|3.n+3*2-1。符号的运算从左到右。该表达式+在*左边，所以先算+，后算*，这和数学中定义的运算符优先级是不一致的 --- 3+4*2的结果为14。

注意:

一、表达式中不能有空格，否则会当成几个由空格隔开的表达式，这和其他多数程序设计系统是不一样的。

二、多数Scheme使用-作为变量分隔符，比如你可以定义一个变量is-a-list，而我们系统支持中缀表达式，-的意义是算术中的减号，is-a-list的意义是是3个变量相减。你应当使用_来分割字符串作为变量名:is_a_list。


中缀和前缀的混合使用：j|3.n+(* 3 2)-1 (未完成)

多数（标准）Scheme里，变量需要先define(定义)，然后set!(赋值)，其实，定义和赋值用一个关键字更好。我们使用set直接定义并赋值，而且一次能定义并赋值多个变量：

(set (a 12) (b 13) (c "hello"))


顺序块 (begin (...) (...) (...))
将依次计算各项，返回最后一项的值；可以嵌套使用。注意：返回值不会在其所在的语句块里打印，而其余各项的值均被打印。

条件块 (if (1) (2) (3)) 
判断1的结果，如果为True，则计算2并返回，否则计算3并返回；23项必须有，可以为();可以嵌套使用。同样，返回值不打印。

循环块 -- 可以嵌套使用
while, for, break

for_each


函数定义define与lambda

多数程序设计系统提供return语句，函数有返回值，zh系统函数没有返回值，我们建议使用函数外层的一个变量作为返回值。例如：
(set (s 0))
(define (sum a b) ( set (s (+ a b))))
(sum 3 4)
以上，变量s可以在sum函数内部访问到，充当sum的返回值。

函数内部可以定义函数，参见newton.s，函数A内定义的函数只能在函数A内使用，A外部的其他函数不能使用。

当函数内有多条语句时，用begin包起来；根节点块可以省略(begin)。


函数调用

函数调用时实参个数不一定要和形参个数一样。

几乎所有的程序设计系统中，函数的调用都是通过名为"栈"(stack)的数据结构，通常，栈空间是连续的。如果用C程序来实现一个栈，最简单的方式是定义一个字符数组：

char s[1024]；

这样，你可以用s这个字符数组才存储函数参数、变量以及返回值。

不过，在我们的程序设计系统中，函数调用形成的并不是栈结构，而是树结构。


class

程序设计者可以使用Python的type函数创建一个类，但是多数情况下，你应该使用class直接定义一个类，使用.操作符访问对象的成员。尽量避免使用type函数，因为type太低层，除非你想自己实现一套面向对象程序设计系统，可以参考type的函数参数和返回值设计。

(class point object (
    (set n 12)
    (define fun (lambda x (* 2 x)))
))


读写文件

读写文件直接使用Python的file对象，以下程序打开test.ss文件，并读取，打印：
(set (f (open "test.ss" "r")))
(print (f.read))


其他常用特性：


并行单元

每个并行单元是一段在一个CPU核心上运行的代码。一个并行单元内的代码是不可能被分配到两个不同的CPU核心上执行的;而不同的并行单元，可能会在同一个CPU核心上执行 -- 线程切换，或者一个并行单元完成后，执行另一个并行单元；在多核CPU计算机上，通常会放在不同的CPU上执行，互不影响。

常规计算和的代码：

    (define (sum x r)
      (if (eq? x 0)
          (print r)
          (sum (- x 1) (+ x r))
       )
    )
    (sum 400 0)

并行后的代码：

(define (sum x y z )
    (if (eq? x y)
        z
        (sum (- x 1) y (+ x r))
     )
)


(thread  s1
    (begin
        (set (s1 0))
        (set (s1 (sum 1000 500 0)))
    )
)

(thread  s2
    (begin
        (set (s2 0))
        (set (s2 (sum 500 0 0)))
    )
)

#这里要等上面两个thread的s1 s2的计算完成后才可计算。
(set (s3 (+ s1 s2)))
(print s3)

一、运行时间 (time (..))  

time --- 关键字，time后只能有一项参数，运行参数项，并打印运行时间。
例如：(time (+ 4 5)) --- 计算”4+5“，并打印运行时间。

你可以用begin将一系列语句包装起来，作为time的参数:
(time (begin (...) (...) (...) (...)))

嵌套使用：
(time (begin (...) (time (...)) (...) (...)))


二、单元测试

单元测试，也就是编写代码测试你的函数。编写单元测试代码，可以避免枯燥重复的手工调试，是良好的编程习惯。

一个运行次数很少、非常简单、几乎不会出错的函数，不需要单元测试；函数越复杂， 输入和输出(参数和返回值)的逻辑关系越复杂，改动越频繁，越需要单元测试。

(test (sum 100 0) 5050)

test关键字运算第二个参数（预期是一个函数调用），如果其结果和第三个参数不符，则打印出错误信息。

我们定义一个函数：
(define (test x y) (if (!= (x) y)
    (print "Not Expect!")
))


三、无用变量的检测警告功能：

new.s文件中定义了一个没有被使用的变量和函数，解释器能够检测到，并给出警告：
(set (abc 123))
(define (efg x) (x))

python Zh.py new.s

E:\Project\Zh>python Zh.py new.s
45150
0
0:00:00.012001
Warn : [ abc ] is not used.
Warn : [ efg ] is not used.


四、递归函数和尾递归

如果一个函数定义内调用了自身，那么该函数是一个递归函数。一个函数是否是递归函数，在定义时已经确定了，而不用等到运行时。一个函数是否递归函数和该函数是否被真正调用无关。

一个递归函数，实际运行时，可能只调用了一次就结束了，并没有发生递归调用。比如上述sum函数，如果你调用(sum 0 0)，sum其实只被调用了一次就结束运行了，但是，Sum仍然是一个递归函数。

  (define (sum x r)
      (if (eq? x 0)
          (print r)
          (sum (- x 1) (+ x r))
       )
    )
   (sum 150 0)

上述函数是一个尾递归函数，对于那些支持尾递归优化的编译器或者解释器，其运行效率和循环相当。

sum在最后可能会调用sum自身。因为在函数的最后调用，函数的局部变量，参数的生命周期即将结束，所以此时不用为新的调用增长栈内存，而直接使用上层的栈空间。这种编译解释器技术称为尾递归优化，很可惜，Python不支持尾递归优化，即使你写出了尾递归程序，但是在实际运行中，Python还是要为每一层递归调用匹配栈库空间。所以，当你使用Python时，除非万不得已，否则，你应该使用循环语句。


五、中文编程

Zh支持使用中文作为过程名（函数名）。对于中文编程，已经有人作出一些尝试，如易语言中文编程、文言文编程。

电子计算机诞生于美国，最先支持的是英文字母，中文等其他国家的文字的支持比较流行的方案是UTF8，早期还有GBK中文编码等方案。

现有的各种程序库通常都是英文的，几乎没有中文程序库。我们应当尝试使用中文命名类名、变量名、函数名，这样，也许，你可以少写点注释、文档。

下面是一个简单的例子：
(define (相加 x y) (+ x y))
(相加 3 4)
以上程序，得到结果7。

某些变量，比如循环自增用的i，这些有着固定套路的变量，用中文命名反而麻烦，没有必要。


ErLang实现Zh

所谓的函数式程序设计，其中一种常见的思想是，变量不能随意赋值，比如ErLang中，其实没有变量，ErLang中所谓的变量只能定义并赋值一次，这在其他程序设计系统被称为“常量”。

ErLang中变量只能赋值一次，支持尾递归，如果我们基于ErLang实现Zh，应该用尾递归函数实现while和for循环。

ErLang中的消息传递模型，和Unix Shell环境下的|管道操作很像。Posix C API中pipe()函数用于创建管道，其区别是，调用Pipe创建管道后，用户发送的数据是字节流，而ErLang传递的消息则是有数据类型的。


泛型

泛型技术是你的函数成倍的减少，适用于所有的静态类型程序设计系统。


单元测试与驱动驱动

编写代码测试你的函数，避免多次手工测试；而测试驱动开发则是测试先行，先写测试代码，然后编写实际的函数和类。单元测试和测试驱动是比面相对象重要的多方法。


面向对象

使用面向对象技术最多的地方可能是GUI库。笔者认为，GUI库并不需要面向对象技术，尤其不需要继承、多态，html、JavaScript就很好，GUI库最需要的是将窗口排版和程序设计分离。最好的GUI库可能是C#的WPF，使用xml来为你的窗口界面排版。


五、zh虽然很像Lisp、Scheme，但是不符合任何一个Lisp，Scheme标准，作者无意实现一个符合某个标准的Scheme或者Lisp。

和Lisp/Scheme的一些区别（不完全）：

一、quote和;用于注释。

取消了Symbol类型，使用python字符串。

二、define和set!

Scheme使用define定义变量，使用set!为变量赋值。在ZH中，define只能定义函数，变量直接用set定义并赋值。set可以一次定义/赋值多个变量。

三、bool类型

Scheme里bool值为#T和#F,Zh直接使用Python的bool型 -- True和False

四、实现了C风格的while，for循环，循环体中可以使用break跳出循环。

五、取消了cons，实现了car和cdr

Scheme中的cons，作用是构造一个pair，包括左右两个值，在ChezScheme和Racket中，(cons 1 2)的输出是(1 . 2)，用.来区分左右两部分，car取得左值，cdr取得右值，可以对一个list取car和cdr。

六、(env)查看当前的环境变量，你可以在任意位置调用

七、(import test.s)导入并执行test.s文件，可以在任意位置调用。

八、取消了call/cc。笔者认为call/cc相对循环和break语句，更难掌握，因此删掉了call/cc相关代码，增加了break关键字 -- 跳出循环。

九、中缀表达式
